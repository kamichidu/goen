package goen

import (
	"encoding/hex"
	"reflect"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

type TextID string

func (s TextID) MarshalText() ([]byte, error) {
	return []byte("MarshalText(" + s + ")"), nil
}

type BlobID string

func (s BlobID) MarshalBinary() ([]byte, error) {
	return []byte("MarshalBinary(" + s + ")"), nil
}

func mustFieldByName(typ reflect.Type, name string) reflect.StructField {
	v, ok := typ.FieldByName(name)
	if !ok {
		panic("no such struct field " + name)
	}
	return v
}

type CommonFields struct {
	CreatedAt time.Time
	UpdatedAt time.Time
}

type Blog struct {
	IDInt    int    `goen:"" table:"blogs" primary_key:""`
	IDString string `primary_key:""`
	IDTextID TextID `primary_key:""`
	IDBlobID BlobID `primary_key:""`
	Name     string
	Posts    []*Post `foreign_key:"id_string"`
}

type Post struct {
	PostID int `goen:"" table:"posts"`
	BlogID string
	Blog   *Blog `foreign_key:"blog_id:id_string"`
	CommonFields
}

type Text struct {
	// table name will be auto generated by type name
	TextID int `goen:"" primary_key:""`

	Msg string
}

func TestMetaSchema(t *testing.T) {
	meta := NewMetaSchema()
	meta.Register(Blog{})
	meta.Register(Post{})
	meta.Register(Text{})
	meta.Compute()

	t.Run("PrimaryKeyOf", func(t *testing.T) {
		blog := &Blog{
			IDInt:    1,
			IDString: "str",
			IDTextID: "tid",
			IDBlobID: "bid",
		}
		pk := meta.PrimaryKeyOf(blog)
		assert.EqualValues(t, &MapRowKey{
			Table: "blogs",
			Key: map[string]interface{}{
				"id_int":     1,
				"id_string":  "str",
				"id_text_id": TextID("tid"),
				"id_blob_id": BlobID("bid"),
			},
		}, pk)

		txt := &Text{
			TextID: 1,
		}
		pk = meta.PrimaryKeyOf(txt)
		assert.EqualValues(t, &MapRowKey{
			Table: "text",
			Key: map[string]interface{}{
				"text_id": 1,
			},
		}, pk)
	})
	t.Run("ReferenceKeysOf", func(t *testing.T) {
		blog := &Blog{
			IDInt:    1,
			IDString: "str",
			IDTextID: "tid",
			IDBlobID: "bid",
		}
		refes := meta.ReferenceKeysOf(blog)
		assert.EqualValues(t, []RowKey{
			&MapRowKey{Table: "blogs", Key: map[string]interface{}{"id_string": "str"}},
		}, refes)

		txt := &Text{
			TextID: 1,
		}
		refes = meta.ReferenceKeysOf(txt)
		assert.Len(t, refes, 0)
	})
	t.Run("KeyStringFromRowKey", func(t *testing.T) {
		key := meta.KeyStringFromRowKey(&MapRowKey{
			Table: "blogs",
			Key: map[string]interface{}{
				"id_int":     1,
				"id_string":  "str",
				"id_text_id": TextID("tid"),
				"id_blob_id": BlobID("bid"),
			},
		})
		// columns are sorted by name
		assert.Equal(t, "blogs;id_blob_id="+hex.EncodeToString([]byte("MarshalBinary(bid)"))+";id_int=1;id_string=str;id_text_id=MarshalText(tid)", key)
	})
	t.Run("InsertPatchOf", func(t *testing.T) {
		patch := meta.InsertPatchOf(Blog{
			IDInt:    1,
			IDString: "str",
			IDTextID: TextID("tid"),
			IDBlobID: BlobID("bid"),
			Name:     "testing",
		})
		assert.Equal(t, &Patch{
			Kind:      PatchInsert,
			TableName: "blogs",
			Columns:   []string{"id_int", "id_string", "id_text_id", "id_blob_id", "name"},
			Values:    []interface{}{1, "str", TextID("tid"), BlobID("bid"), "testing"},
		}, patch)
	})
	t.Run("UpdatePatchOf", func(t *testing.T) {
		patch := meta.UpdatePatchOf(Blog{
			IDInt:    1,
			IDString: "str",
			IDTextID: TextID("tid"),
			IDBlobID: BlobID("bid"),
			Name:     "testing",
		})
		assert.Equal(t, &Patch{
			Kind:      PatchUpdate,
			TableName: "blogs",
			Columns:   []string{"name"},
			Values:    []interface{}{"testing"},
			RowKey: &MapRowKey{
				Table: "blogs",
				Key: map[string]interface{}{
					"id_int":     1,
					"id_string":  "str",
					"id_text_id": TextID("tid"),
					"id_blob_id": BlobID("bid"),
				},
			},
		}, patch)
	})
	t.Run("DeletePatchOf", func(t *testing.T) {
		patch := meta.DeletePatchOf(Blog{
			IDInt:    1,
			IDString: "str",
			IDTextID: TextID("tid"),
			IDBlobID: BlobID("bid"),
			Name:     "testing",
		})
		assert.Equal(t, &Patch{
			Kind:      PatchDelete,
			TableName: "blogs",
			RowKey: &MapRowKey{
				Table: "blogs",
				Key: map[string]interface{}{
					"id_int":     1,
					"id_string":  "str",
					"id_text_id": TextID("tid"),
					"id_blob_id": BlobID("bid"),
				},
			},
		}, patch)
	})
	t.Run("LoadOf", func(t *testing.T) {
		meta := meta.LoadOf(new(Blog))
		typ := reflect.TypeOf(Blog{})
		assert.Equal(t, &metaTable{
			typ:       typ,
			tableName: "blogs",
			primaryKey: []MetaColumn{
				&metaColumn{
					field:            mustFieldByName(typ, "IDInt"),
					partOfPrimaryKey: true,
					columnName:       "id_int",
				},
				&metaColumn{
					field:            mustFieldByName(typ, "IDString"),
					partOfPrimaryKey: true,
					columnName:       "id_string",
				},
				&metaColumn{
					field:            mustFieldByName(typ, "IDTextID"),
					partOfPrimaryKey: true,
					columnName:       "id_text_id",
				},
				&metaColumn{
					field:            mustFieldByName(typ, "IDBlobID"),
					partOfPrimaryKey: true,
					columnName:       "id_blob_id",
				},
			},
			columns: []MetaColumn{
				&metaColumn{
					field:            mustFieldByName(typ, "IDInt"),
					partOfPrimaryKey: true,
					columnName:       "id_int",
				},
				&metaColumn{
					field:            mustFieldByName(typ, "IDString"),
					partOfPrimaryKey: true,
					columnName:       "id_string",
				},
				&metaColumn{
					field:            mustFieldByName(typ, "IDTextID"),
					partOfPrimaryKey: true,
					columnName:       "id_text_id",
				},
				&metaColumn{
					field:            mustFieldByName(typ, "IDBlobID"),
					partOfPrimaryKey: true,
					columnName:       "id_blob_id",
				},
				&metaColumn{
					field:            mustFieldByName(typ, "Name"),
					partOfPrimaryKey: false,
					columnName:       "name",
				},
			},
			referenceKeys: [][]MetaColumn{
				[]MetaColumn{
					&metaColumn{
						field:            mustFieldByName(typ, "IDString"),
						partOfPrimaryKey: true,
						columnName:       "id_string",
					},
				},
			},
		}, meta)
	})
}
